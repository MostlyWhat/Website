"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DiagnosticsProviderImpl = void 0;
const typescript_1 = __importDefault(require("typescript"));
const vscode_languageserver_1 = require("vscode-languageserver");
const documents_1 = require("../../../core/documents");
const utils_1 = require("../utils");
const utils_2 = require("./utils");
class DiagnosticsProviderImpl {
    constructor(languageServiceManager) {
        this.languageServiceManager = languageServiceManager;
    }
    async getDiagnostics(document, _cancellationToken) {
        var _a, _b, _c, _d, _e;
        if ((((_a = document.getFilePath()) === null || _a === void 0 ? void 0 : _a.includes('/node_modules/')) ||
            ((_b = document.getFilePath()) === null || _b === void 0 ? void 0 : _b.includes('\\node_modules\\'))) &&
            // Sapper convention: Put stuff inside node_modules below src
            !(((_c = document.getFilePath()) === null || _c === void 0 ? void 0 : _c.includes('/src/node_modules/')) ||
                ((_d = document.getFilePath()) === null || _d === void 0 ? void 0 : _d.includes('\\src\\node_modules\\')))) {
            // Don't return diagnostics for files inside node_modules. These are considered read-only (cannot be changed)
            // and in case of svelte-check they would pollute/skew the output
            return [];
        }
        const { lang, tsDoc } = await this.getLSAndTSDoc(document);
        const isTypescript = tsDoc.scriptKind === typescript_1.default.ScriptKind.TSX;
        // Document preprocessing failed, show parser error instead
        if (tsDoc.parserError) {
            return [
                {
                    range: tsDoc.parserError.range,
                    severity: vscode_languageserver_1.DiagnosticSeverity.Error,
                    source: isTypescript ? 'ts' : 'js',
                    message: tsDoc.parserError.message,
                    code: tsDoc.parserError.code
                }
            ];
        }
        const filePath = (0, utils_1.toVirtualAstroFilePath)(tsDoc.filePath);
        const { script: scriptBoundaries, markdown: markdownBoundaries } = this.getTagBoundaries(lang, filePath);
        const syntaxDiagnostics = lang.getSyntacticDiagnostics(filePath);
        const suggestionDiagnostics = lang.getSuggestionDiagnostics(filePath);
        const semanticDiagnostics = lang.getSemanticDiagnostics(filePath).filter(d => {
            return (isNoWithinScript(scriptBoundaries, d));
        });
        const diagnostics = [
            ...syntaxDiagnostics,
            ...suggestionDiagnostics,
            ...semanticDiagnostics
        ];
        const fragment = await tsDoc.getFragment();
        const sourceFile = (_e = lang.getProgram()) === null || _e === void 0 ? void 0 : _e.getSourceFile(filePath);
        const isNoFalsePositiveInst = isNoFalsePositive();
        return diagnostics
            .filter(isNotGenerated(tsDoc.getText(0, tsDoc.getLength())))
            .map((diagnostic) => ({
            range: (0, utils_1.convertRange)(tsDoc, diagnostic),
            severity: (0, utils_1.mapSeverity)(diagnostic.category),
            source: isTypescript ? 'ts' : 'js',
            message: typescript_1.default.flattenDiagnosticMessageText(diagnostic.messageText, '\n'),
            code: diagnostic.code,
            tags: getDiagnosticTag(diagnostic)
        }))
            .map(mapRange(fragment, document))
            .filter(diag => {
            return (hasNoNegativeLines(diag) &&
                isNoFalsePositiveInst(diag) &&
                isNoJSXImplicitRuntimeWarning(diag) &&
                isNoJSXMustHaveOneParent(diag) &&
                isNoCantUseJSX(diag) &&
                isNoCantEndWithTS(diag) &&
                isNoSpreadExpected(diag) &&
                isNoCantResolveJSONModule(diag) &&
                isNoMarkdownBlockQuoteWithinMarkdown(sourceFile, markdownBoundaries, diag));
        })
            .map(enhanceIfNecessary);
    }
    async getLSAndTSDoc(document) {
        return this.languageServiceManager.getTypeScriptDoc(document);
    }
    getTagBoundaries(lang, tsFilePath) {
        const program = lang.getProgram();
        const sourceFile = program === null || program === void 0 ? void 0 : program.getSourceFile(tsFilePath);
        const boundaries = {
            script: [],
            markdown: []
        };
        if (!sourceFile) {
            return boundaries;
        }
        function findScript(parent) {
            typescript_1.default.forEachChild(parent, node => {
                if (typescript_1.default.isJsxElement(node)) {
                    let tagName = node.openingElement.tagName.getText();
                    switch (tagName) {
                        case 'script': {
                            typescript_1.default.getLineAndCharacterOfPosition(sourceFile, node.getStart());
                            boundaries.script.push([node.getStart(), node.getEnd()]);
                            break;
                        }
                        case 'Markdown': {
                            boundaries.markdown.push([node.getStart(), node.getEnd()]);
                            break;
                        }
                    }
                }
                findScript(node);
            });
        }
        findScript(sourceFile);
        return boundaries;
    }
}
exports.DiagnosticsProviderImpl = DiagnosticsProviderImpl;
function getDiagnosticTag(diagnostic) {
    const tags = [];
    if (diagnostic.reportsUnnecessary) {
        tags.push(vscode_languageserver_1.DiagnosticTag.Unnecessary);
    }
    if (diagnostic.reportsDeprecated) {
        tags.push(vscode_languageserver_1.DiagnosticTag.Deprecated);
    }
    return tags;
}
function mapRange(fragment, _document) {
    return (diagnostic) => {
        let range = (0, documents_1.mapRangeToOriginal)(fragment, diagnostic.range);
        if (range.start.line < 0) {
            // Could be a props error?
            // From svelte
        }
        return { ...diagnostic, range };
    };
}
/**
 * In some rare cases mapping of diagnostics does not work and produces negative lines.
 * We filter out these diagnostics with negative lines because else the LSP
 * apparently has a hickup and does not show any diagnostics at all.
 */
function hasNoNegativeLines(diagnostic) {
    return diagnostic.range.start.line >= 0 && diagnostic.range.end.line >= 0;
}
function isNoFalsePositive() {
    return (diagnostic) => {
        return (isNoJsxCannotHaveMultipleAttrsError(diagnostic));
    };
}
/**
 * Jsx cannot have multiple attributes with same name,
 * but that's allowed for svelte
 */
function isNoJsxCannotHaveMultipleAttrsError(diagnostic) {
    return diagnostic.code !== 17001;
}
function isNoJSXImplicitRuntimeWarning(diagnostic) {
    return diagnostic.code !== 7016 && diagnostic.code !== 2792;
}
function isNoJSXMustHaveOneParent(diagnostic) {
    return diagnostic.code !== 2657;
}
function isNoCantUseJSX(diagnostic) {
    return diagnostic.code !== 17004 && diagnostic.code !== 6142;
}
function isNoCantEndWithTS(diagnostic) {
    return diagnostic.code !== 2691;
}
function isNoSpreadExpected(diagnostic) {
    return diagnostic.code !== 1005;
}
function isWithinBoundaries(boundaries, start) {
    for (let [bstart, bend] of boundaries) {
        if (start > bstart && start < bend) {
            return true;
        }
    }
    return false;
}
function diagnosticIsWithinBoundaries(sourceFile, boundaries, diagnostic) {
    if ('start' in diagnostic) {
        if (diagnostic.start == null)
            return false;
        return isWithinBoundaries(boundaries, diagnostic.start);
    }
    if (!sourceFile)
        return false;
    let startRange = diagnostic.range.start;
    let pos = typescript_1.default.getPositionOfLineAndCharacter(sourceFile, startRange.line, startRange.character);
    return isWithinBoundaries(boundaries, pos);
}
function isNoWithinScript(boundaries, diagnostic) {
    return !diagnosticIsWithinBoundaries(undefined, boundaries, diagnostic);
}
/**
 * This allows us to have JSON module imports.
 */
function isNoCantResolveJSONModule(diagnostic) {
    return diagnostic.code !== 2732;
}
/**
 * This is for using > within a markdown component like:
 * <Markdown>
 *   > Blockquote here.
 * </Markdown>
 */
function isNoMarkdownBlockQuoteWithinMarkdown(sourceFile, boundaries, diagnostic) {
    if (diagnostic.code !== 1382) {
        return true;
    }
    return !diagnosticIsWithinBoundaries(sourceFile, boundaries, diagnostic);
}
/**
 * Some diagnostics have JSX-specific nomenclature. Enhance them for more clarity.
 */
function enhanceIfNecessary(diagnostic) {
    if (diagnostic.code === 2786) {
        return {
            ...diagnostic,
            message: 'Type definitions are missing for this Svelte Component. ' +
                // eslint-disable-next-line max-len
                "It needs a class definition with at least the property '$$prop_def' which should contain a map of input property definitions.\n" +
                'Example:\n' +
                '  class ComponentName { $$prop_def: { propertyName: string; } }\n' +
                'If you are using Svelte 3.31+, use SvelteComponentTyped:\n' +
                '  import type { SvelteComponentTyped } from "svelte";\n' +
                '  class ComponentName extends SvelteComponentTyped<{propertyName: string;}> {}\n\n' +
                'Underlying error:\n' +
                diagnostic.message
        };
    }
    if (diagnostic.code === 2607) {
        return {
            ...diagnostic,
            message: 'Element does not support attributes because ' +
                'type definitions are missing for this Svelte Component or element cannot be used as such.\n\n' +
                'Underlying error:\n' +
                diagnostic.message
        };
    }
    if (diagnostic.code === 1184) {
        return {
            ...diagnostic,
            message: diagnostic.message +
                '\nIf this is a declare statement, move it into <script context="module">..</script>'
        };
    }
    return diagnostic;
}
/**
 * Checks if diagnostic is not within a section that should be completely ignored
 * because it's purely generated.
 */
function isNotGenerated(text) {
    return (diagnostic) => {
        if (diagnostic.start === undefined || diagnostic.length === undefined) {
            return true;
        }
        return !(0, utils_2.isInGeneratedCode)(text, diagnostic.start, diagnostic.start + diagnostic.length);
    };
}
