"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeScriptDocumentSnapshot = exports.DocumentFragmentSnapshot = exports.createDocumentSnapshot = void 0;
const ts = __importStar(require("typescript"));
const documents_1 = require("../../core/documents");
const utils_1 = require("../../core/documents/utils");
const utils_2 = require("../../utils");
const utils_3 = require("./utils");
const os_1 = require("os");
const astro2tsx_1 = __importDefault(require("./astro2tsx"));
const createDocumentSnapshot = (filePath, currentText, createDocument) => {
    var _a;
    const text = currentText || ((_a = ts.sys.readFile(filePath)) !== null && _a !== void 0 ? _a : '');
    if ((0, utils_3.isAstroFilePath)(filePath)) {
        if (!createDocument)
            throw new Error('Astro documents require the "createDocument" utility to be provided');
        const snapshot = new AstroDocumentSnapshot(createDocument(filePath, text, currentText !== null));
        return snapshot;
    }
    return new TypeScriptDocumentSnapshot(0, filePath, text);
};
exports.createDocumentSnapshot = createDocumentSnapshot;
class AstroDocumentSnapshot {
    constructor(doc) {
        this.doc = doc;
        this.version = this.doc.version;
        this.scriptKind = ts.ScriptKind.Unknown;
        this.parserError = null;
    }
    async getFragment() {
        const uri = (0, utils_2.pathToUrl)(this.filePath);
        const mapper = await this.getMapper(uri);
        return new DocumentFragmentSnapshot(mapper, this.doc);
    }
    async destroyFragment() {
        return;
    }
    get text() {
        let raw = this.doc.getText();
        return (0, astro2tsx_1.default)(raw).code;
    }
    get filePath() {
        return this.doc.getFilePath() || '';
    }
    getText(start, end) {
        return this.text.substring(start, end);
    }
    getLength() {
        return this.text.length;
    }
    getFullText() {
        return this.text;
    }
    getChangeRange() {
        return undefined;
    }
    positionAt(offset) {
        return (0, utils_1.positionAt)(offset, this.text);
    }
    getLineContainingOffset(offset) {
        const chunks = this.getText(0, offset).split(os_1.EOL);
        return chunks[chunks.length - 1];
    }
    offsetAt(position) {
        return (0, utils_1.offsetAt)(position, this.text);
    }
    getMapper(uri) {
        return new documents_1.IdentityMapper(uri);
    }
}
class DocumentFragmentSnapshot {
    constructor(mapper, parent) {
        this.mapper = mapper;
        this.parent = parent;
        this.parserError = null;
        this.scriptKind = ts.ScriptKind.TSX;
        this.scriptInfo = null;
        const filePath = parent.getFilePath();
        if (!filePath)
            throw new Error('Cannot create a document fragment from a non-local document');
        const text = parent.getText();
        this.version = parent.version;
        this.filePath = (0, utils_3.toVirtualAstroFilePath)(filePath);
        this.url = (0, utils_3.toVirtualAstroFilePath)(filePath);
        this.text = (0, astro2tsx_1.default)(text).code;
    }
    getText(start, end) {
        return this.text.substring(start, end);
    }
    getLength() {
        return this.text.length;
    }
    getFullText() {
        return this.text;
    }
    getChangeRange() {
        return undefined;
    }
    positionAt(offset) {
        return (0, utils_1.positionAt)(offset, this.text);
    }
    getLineContainingOffset(offset) {
        const chunks = this.getText(0, offset).split(os_1.EOL);
        return chunks[chunks.length - 1];
    }
    offsetAt(position) {
        return (0, utils_1.offsetAt)(position, this.text);
    }
    getOriginalPosition(pos) {
        return this.mapper.getOriginalPosition(pos);
    }
    getGeneratedPosition(pos) {
        return this.mapper.getGeneratedPosition(pos);
    }
    isInGenerated(pos) {
        return !(0, utils_1.isInTag)(pos, this.parent.styleInfo);
    }
    getURL() {
        return this.url;
    }
}
exports.DocumentFragmentSnapshot = DocumentFragmentSnapshot;
class TypeScriptDocumentSnapshot {
    constructor(version, filePath, text) {
        this.version = version;
        this.filePath = filePath;
        this.text = text;
        this.scriptKind = (0, utils_3.getScriptKindFromFileName)(this.filePath);
        this.scriptInfo = null;
        this.parserError = null;
        this.url = (0, utils_2.pathToUrl)(filePath);
    }
    getText(start, end) {
        return this.text.substring(start, end);
    }
    getLength() {
        return this.text.length;
    }
    getFullText() {
        return this.text;
    }
    getChangeRange() {
        return undefined;
    }
    positionAt(offset) {
        return (0, utils_1.positionAt)(offset, this.text);
    }
    offsetAt(position) {
        return (0, utils_1.offsetAt)(position, this.text);
    }
    async getFragment() {
        return this;
    }
    getOriginalPosition(pos) {
        return pos;
    }
    destroyFragment() {
        // nothing to clean up
    }
    getLineContainingOffset(offset) {
        const chunks = this.getText(0, offset).split('\n');
        return chunks[chunks.length - 1];
    }
    update(changes) {
        for (const change of changes) {
            let start = 0;
            let end = 0;
            if ('range' in change) {
                start = this.offsetAt(change.range.start);
                end = this.offsetAt(change.range.end);
            }
            else {
                end = this.getLength();
            }
            this.text = this.text.slice(0, start) + change.text + this.text.slice(end);
        }
        this.version++;
    }
}
exports.TypeScriptDocumentSnapshot = TypeScriptDocumentSnapshot;
