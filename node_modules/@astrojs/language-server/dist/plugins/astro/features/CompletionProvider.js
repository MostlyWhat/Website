"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CompletionProvider = void 0;
const vscode_languageserver_1 = require("vscode-languageserver");
const ts = __importStar(require("typescript"));
const utils_1 = require("../../../core/documents/utils");
const utils_2 = require("../../../utils");
const utils_3 = require("../../typescript/utils");
class CompletionProvider {
    constructor(docManager, tsLanguageServiceManager) {
        this.docManager = docManager;
        this.tsLanguageServiceManager = tsLanguageServiceManager;
    }
    async getCompletions(document, position, completionContext) {
        const doc = this.docManager.get(document.uri);
        if (!doc)
            return null;
        let items = [];
        if ((completionContext === null || completionContext === void 0 ? void 0 : completionContext.triggerCharacter) === '-') {
            const frontmatter = this.getComponentScriptCompletion(doc, position, completionContext);
            if (frontmatter)
                items.push(frontmatter);
        }
        if ((completionContext === null || completionContext === void 0 ? void 0 : completionContext.triggerCharacter) === ':') {
            const clientHint = this.getClientHintCompletion(doc, position, completionContext);
            if (clientHint)
                items.push(...clientHint);
        }
        if (!this.isInsideFrontmatter(document, position)) {
            const props = await this.getPropCompletions(document, position, completionContext);
            if (props.length) {
                items.push(...props);
            }
        }
        return vscode_languageserver_1.CompletionList.create(items, true);
    }
    getClientHintCompletion(document, position, completionContext) {
        const node = document.html.findNodeAt(document.offsetAt(position));
        if (!(0, utils_2.isPossibleClientComponent)(node))
            return null;
        return [
            {
                label: ':load',
                insertText: 'load',
                commitCharacters: ['l'],
            },
            {
                label: ':idle',
                insertText: 'idle',
                commitCharacters: ['i'],
            },
            {
                label: ':visible',
                insertText: 'visible',
                commitCharacters: ['v'],
            },
            {
                label: ':media',
                insertText: 'media',
                commitCharacters: ['m']
            }
        ];
    }
    getComponentScriptCompletion(document, position, completionContext) {
        const base = {
            kind: vscode_languageserver_1.CompletionItemKind.Snippet,
            label: '---',
            sortText: '\0',
            preselect: true,
            detail: 'Component script',
            insertTextFormat: vscode_languageserver_1.InsertTextFormat.Snippet,
            commitCharacters: ['-'],
        };
        const prefix = document.getLineUntilOffset(document.offsetAt(position));
        if (document.astro.frontmatter.state === null) {
            return {
                ...base,
                insertText: '---\n$0\n---',
                textEdit: prefix.match(/^\s*\-+/) ? vscode_languageserver_1.TextEdit.replace({ start: { ...position, character: 0 }, end: position }, '---\n$0\n---') : undefined,
            };
        }
        if (document.astro.frontmatter.state === 'open') {
            return {
                ...base,
                insertText: '---',
                textEdit: prefix.match(/^\s*\-+/) ? vscode_languageserver_1.TextEdit.replace({ start: { ...position, character: 0 }, end: position }, '---') : undefined,
            };
        }
        return null;
    }
    async getPropCompletions(document, position, completionContext) {
        var _a, _b;
        const offset = document.offsetAt(position);
        const html = document.html;
        const node = html.findNodeAt(offset);
        if (!this.isComponentTag(node)) {
            return [];
        }
        const inAttribute = node.start + node.tag.length < offset;
        if (!inAttribute) {
            return [];
        }
        if ((completionContext === null || completionContext === void 0 ? void 0 : completionContext.triggerCharacter) === '/' || (completionContext === null || completionContext === void 0 ? void 0 : completionContext.triggerCharacter) === '>') {
            return [];
        }
        // If inside of attribute value, skip.
        if (completionContext && completionContext.triggerKind === vscode_languageserver_1.CompletionTriggerKind.TriggerCharacter && completionContext.triggerCharacter === '"') {
            return [];
        }
        const componentName = node.tag;
        const { lang: thisLang } = await this.tsLanguageServiceManager.getTypeScriptDoc(document);
        // Get the source file
        const filePath = (0, utils_2.urlToPath)(document.uri);
        const tsFilePath = (0, utils_3.toVirtualAstroFilePath)(filePath);
        const program = thisLang.getProgram();
        const sourceFile = program === null || program === void 0 ? void 0 : program.getSourceFile(tsFilePath);
        const typeChecker = program === null || program === void 0 ? void 0 : program.getTypeChecker();
        if (!sourceFile || !typeChecker) {
            return [];
        }
        // Get the import statement
        const imp = this.getImportedSymbol(sourceFile, componentName);
        const importType = imp && typeChecker.getTypeAtLocation(imp);
        if (!importType) {
            return [];
        }
        // Get the import's type
        const componentType = this.getPropType(importType, typeChecker);
        if (!componentType) {
            return [];
        }
        const completionItems = [];
        // Add completions for this types props
        for (let baseType of componentType.getBaseTypes() || []) {
            const members = ((_a = baseType.getSymbol()) === null || _a === void 0 ? void 0 : _a.members) || [];
            members.forEach(mem => {
                let completionItem = this.getCompletionItemForTypeMember(mem, typeChecker);
                completionItems.push(completionItem);
            });
        }
        // Add completions for this types base members
        const members = ((_b = componentType.getSymbol()) === null || _b === void 0 ? void 0 : _b.members) || [];
        members.forEach(mem => {
            let completionItem = this.getCompletionItemForTypeMember(mem, typeChecker);
            completionItems.push(completionItem);
        });
        return completionItems;
    }
    getImportedSymbol(sourceFile, identifier) {
        for (let list of sourceFile.getChildren()) {
            for (let node of list.getChildren()) {
                if (ts.isImportDeclaration(node)) {
                    let clauses = node.importClause;
                    if (!clauses)
                        return null;
                    let namedImport = clauses.getChildAt(0);
                    if (ts.isNamedImports(namedImport)) {
                        for (let imp of namedImport.elements) { // Iterate the named imports
                            if (imp.name.getText() === identifier) {
                                return imp;
                            }
                        }
                    }
                    else if (ts.isIdentifier(namedImport)) {
                        if (namedImport.getText() === identifier) {
                            return namedImport;
                        }
                    }
                }
            }
        }
        return null;
    }
    getPropType(type, typeChecker) {
        const sym = type === null || type === void 0 ? void 0 : type.getSymbol();
        if (!sym) {
            return null;
        }
        for (const decl of (sym === null || sym === void 0 ? void 0 : sym.getDeclarations()) || []) {
            const fileName = decl.getSourceFile().fileName;
            if ((0, utils_3.isVirtualAstroFilePath)(fileName)) {
                if (!ts.isFunctionDeclaration(decl)) {
                    console.error(`Unexpected: .astro files should export a default function for the component definition.`);
                    continue;
                }
                const fn = decl;
                if (!fn.parameters.length)
                    continue;
                const param1 = fn.parameters[0];
                const type = typeChecker.getTypeAtLocation(param1);
                return type;
            }
            else if (fileName.endsWith('.tsx') || fileName.endsWith('.jsx')) {
                if (!ts.isFunctionDeclaration(decl)) {
                    console.error(`We only support function components for tsx/jsx at the moment.`);
                    continue;
                }
                const fn = decl;
                if (!fn.parameters.length)
                    continue;
                const param1 = fn.parameters[0];
                const type = typeChecker.getTypeAtLocation(param1);
                return type;
            }
        }
        return null;
    }
    getCompletionItemForTypeMember(mem, typeChecker) {
        let item = {
            label: mem.name,
            insertText: mem.name,
            commitCharacters: [],
        };
        mem.getDocumentationComment(typeChecker);
        let description = mem
            .getDocumentationComment(typeChecker)
            .map((val) => val.text)
            .join('\n');
        if (description) {
            let docs = {
                kind: vscode_languageserver_1.MarkupKind.Markdown,
                value: description,
            };
            item.documentation = docs;
        }
        return item;
    }
    isComponentTag(node) {
        if (!node.tag) {
            return false;
        }
        const firstChar = node.tag[0];
        return /[A-Z]/.test(firstChar);
    }
    isInsideFrontmatter(document, position) {
        return (0, utils_1.isInsideFrontmatter)(document.getText(), document.offsetAt(position));
    }
}
exports.CompletionProvider = CompletionProvider;
